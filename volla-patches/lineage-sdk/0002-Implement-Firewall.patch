From 38deb0946ae058521ce02db8c8264de63429f77f Mon Sep 17 00:00:00 2001
From: Erfan Abdi <erfangplus@gmail.com>
Date: Fri, 11 Feb 2022 19:58:13 +0330
Subject: [PATCH] Implement Firewall

Change-Id: I085ced3f4a31f6c182f957445cf0533f8cd71303
---
 Android.mk                                    |   2 +-
 api/lineage_current.txt                       |  18 +
 .../platform/internal/FirewallService.java    | 426 ++++++++++++++++++
 lineage/res/res/values/config.xml             |   1 +
 .../app/LineageContextConstants.java          |   7 +
 .../lineageos/firewall/FirewallManager.java   | 147 ++++++
 .../lineageos/firewall/IFirewallService.aidl  |  39 ++
 7 files changed, 639 insertions(+), 1 deletion(-)
 create mode 100644 lineage/lib/main/java/org/lineageos/platform/internal/FirewallService.java
 create mode 100644 sdk/src/java/lineageos/firewall/FirewallManager.java
 create mode 100644 sdk/src/java/lineageos/firewall/IFirewallService.aidl

diff --git a/Android.mk b/Android.mk
index 41d55d84..135c697f 100644
--- a/Android.mk
+++ b/Android.mk
@@ -29,7 +29,7 @@ include $(CLEAR_VARS)
 lineage_platform_res := APPS/org.lineageos.platform-res_intermediates/aapt
 
 # List of packages used in lineage-api-stubs
-lineage_stub_packages := lineageos.app:lineageos.content:lineageos.hardware:lineageos.media:lineageos.os:lineageos.preference:lineageos.profiles:lineageos.providers:lineageos.platform:lineageos.util:lineageos.trust:lineageos.applock
+lineage_stub_packages := lineageos.app:lineageos.content:lineageos.hardware:lineageos.media:lineageos.os:lineageos.preference:lineageos.profiles:lineageos.providers:lineageos.platform:lineageos.util:lineageos.trust:lineageos.applock:lineageos.firewall
 
 lineage_framework_module := $(LOCAL_INSTALLED_MODULE)
 
diff --git a/api/lineage_current.txt b/api/lineage_current.txt
index 8186e891..6c9a7db4 100644
--- a/api/lineage_current.txt
+++ b/api/lineage_current.txt
@@ -870,3 +870,21 @@ package lineageos.applock {
   }
 
 }
+
+package lineageos.firewall {
+
+  public class FirewallManager {
+    method public static lineageos.firewall.FirewallManager getInstance(android.content.Context);
+    method public static lineageos.firewall.FirewallManager getService();
+    method public void activate(boolean);
+    method public boolean isActivate();
+    method public void blacklistMode(boolean);
+    method public boolean isBlacklistMode();
+    method public void addDomainToList(java.lang.String);
+    method public void removeDomainFromList(java.lang.String);
+    method public boolean isDomainOnList(java.lang.String);
+    method public int getDomainsListCount();
+    java.util.List<java.lang.String> getDomainsList();
+  }
+
+}
diff --git a/lineage/lib/main/java/org/lineageos/platform/internal/FirewallService.java b/lineage/lib/main/java/org/lineageos/platform/internal/FirewallService.java
new file mode 100644
index 00000000..4dee74d8
--- /dev/null
+++ b/lineage/lib/main/java/org/lineageos/platform/internal/FirewallService.java
@@ -0,0 +1,426 @@
+/**
+ * Copyright (C) 2022 Hallo Welt Systeme UG
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.lineageos.platform.internal;
+
+import android.app.ActivityManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.net.Uri;
+import android.os.Environment;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.SystemProperties;
+import android.os.UserManager;
+import android.provider.Settings;
+import android.util.ArrayMap;
+import android.util.ArraySet;
+import android.util.AtomicFile;
+import android.util.Slog;
+import android.util.Xml;
+
+import com.android.internal.os.BackgroundThread;
+import com.android.server.SystemService;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.IntStream;
+
+import libcore.io.IoUtils;
+import lineageos.app.LineageContextConstants;
+import lineageos.firewall.IFirewallService;
+
+import static android.net.NetworkCapabilities.MIN_TRANSPORT;
+import static android.net.NetworkCapabilities.MAX_TRANSPORT;
+
+import android.net.Network;
+import android.net.ConnectivityManager;
+import android.net.LinkProperties;
+import android.net.IDnsResolver;
+import android.net.shared.PrivateDnsConfig;
+import com.android.server.connectivity.MockableSystemProperties;
+import com.android.server.connectivity.DnsManager;
+
+public class FirewallService extends LineageSystemService {
+
+    private static final String TAG = "FirewallService";
+    private static final boolean DEBUG_FIREWALL = true;
+
+    private static final String FILE_NAME = "list-domains.xml";
+    private static final String TAG_LISTED_DOMAINS = "list-domains";
+    private static final String TAG_DOMAIN = "domain";
+    private static final String ATTRIBUTE_NAME = "name";
+    private static final String COMMON_DNS = "1.1.1.1";
+
+    private int mUserId;
+    private Context mContext;
+
+    private AtomicFile mFile;
+    private final FirewallHandler mHandler;
+
+    private final ArrayList<String> mDomainsList = new ArrayList<String>();
+
+    public FirewallService(Context context) {
+        super(context);
+
+        mContext = context;
+        mHandler = new FirewallHandler(BackgroundThread.getHandler().getLooper());
+        mUserId = ActivityManager.getCurrentUser();
+    }
+
+    @Override
+    public String getFeatureDeclaration() {
+        return LineageContextConstants.Features.HARDWARE_ABSTRACTION;
+    }
+
+    @Override
+    public void onStart() {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "Starting FirewallService");
+        publishBinderService(LineageContextConstants.VOLLA_FIREWALL_SERVICE, mService);
+    }
+
+    @Override
+    public void onUnlockUser(int userHandle) {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "onUnlockUser() mUserId:" + userHandle);
+        if (!UserManager.get(mContext).isManagedProfile(userHandle)) {
+            if (DEBUG_FIREWALL) Slog.v(TAG, "onUnlockUser() is NOT ManagedProfile");
+            mUserId = userHandle;
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_INIT_APPS);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+        }
+    }
+
+    @Override
+    public void onBootPhase(int phase) {
+        if (phase == SystemService.PHASE_SYSTEM_SERVICES_READY) {
+            if (DEBUG_FIREWALL) Slog.v(TAG, "onBootPhase PHASE_SYSTEM_SERVICES_READY");
+            if (isActivate())
+                SystemProperties.set("ctl.start", "volla.dnsmasq");
+        }
+    }
+
+    @Override
+    public void onSwitchUser(int userHandle) {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "onSwitchUser() mUserId:" + userHandle);
+        if (!UserManager.get(mContext).isManagedProfile(userHandle)) {
+            if (DEBUG_FIREWALL) Slog.v(TAG, "onSwitchUser() is NOT ManagedProfile");
+            mUserId = userHandle;
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_INIT_APPS);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+        }
+    }
+
+    @Override
+    public void onStopUser(int userHandle) {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "onStopUser() userHandle:" + userHandle);
+        if (mUserId == userHandle) {
+            mUserId = ActivityManager.getCurrentUser();
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_INIT_APPS);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+        }
+    }
+
+    private void initLockedApps() {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "initLockedApps(" + mUserId + ")");
+        mFile = new AtomicFile(getFile());
+        readState();
+    }
+
+    private File getFile() {
+        File file = new File(Environment.getDataSystemCeDirectory(mUserId), FILE_NAME);
+        if (DEBUG_FIREWALL) Slog.v(TAG, "getFile(): " + file.getAbsolutePath());
+        return file;
+    }
+
+    private void readState() {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "readState()");
+        mDomainsList.clear();
+        try (FileInputStream in = mFile.openRead()) {
+            XmlPullParser parser = Xml.newPullParser();
+            parser.setInput(in, null);
+            parseXml(parser);
+            if (DEBUG_FIREWALL) Slog.v(TAG, "Read " + FILE_NAME + " successfully");
+        } catch (FileNotFoundException e) {
+            if (DEBUG_FIREWALL) Slog.v(TAG, FILE_NAME + " not found");
+            Slog.i(TAG, FILE_NAME + " not found");
+        } catch (XmlPullParserException | IOException e) {
+            throw new IllegalStateException("Failed to parse " + FILE_NAME + ": " + mFile, e);
+        }
+    }
+
+    private void parseXml(XmlPullParser parser) throws IOException,
+            XmlPullParserException {
+        int type;
+        int depth;
+        int innerDepth = parser.getDepth() + 1;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
+            if (depth > innerDepth || type != XmlPullParser.START_TAG) {
+                continue;
+            }
+            if (parser.getName().equals(TAG_LISTED_DOMAINS)) {
+                parsePackages(parser);
+                return;
+            }
+        }
+        Slog.w(TAG, "Missing <" + TAG_LISTED_DOMAINS + "> in " + FILE_NAME);
+    }
+
+    private void parsePackages(XmlPullParser parser) throws IOException,
+            XmlPullParserException {
+        int type;
+        int depth;
+        int innerDepth = parser.getDepth() + 1;
+        boolean writeAfter = false;
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
+            if (depth > innerDepth || type != XmlPullParser.START_TAG) {
+                continue;
+            }
+            if (parser.getName().equals(TAG_DOMAIN)) {
+                String domainName = parser.getAttributeValue(null, ATTRIBUTE_NAME);
+                mDomainsList.add(domainName);
+                if (DEBUG_FIREWALL) Slog.v(TAG, "parsePackages(): domainName=" + domainName);
+            }
+        }
+    }
+
+    private void writeState() {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "writeState()");
+
+        FileOutputStream out = null;
+        try {
+            out = mFile.startWrite();
+            XmlSerializer serializer = Xml.newSerializer();
+            serializer.setOutput(out, StandardCharsets.UTF_8.name());
+            serializer.setFeature(
+                    "http://xmlpull.org/v1/doc/features.html#indent-output", true);
+            serializer.startDocument(null, true);
+            serializeLockedApps(serializer);
+            serializer.endDocument();
+            mFile.finishWrite(out);
+            if (DEBUG_FIREWALL) Slog.v(TAG, "Wrote " + FILE_NAME + " successfully");
+        } catch (IllegalArgumentException | IllegalStateException | IOException e) {
+            Slog.wtf(TAG, "Failed to write " + FILE_NAME + ", restoring backup", e);
+            if (out != null) {
+                mFile.failWrite(out);
+            }
+        } finally {
+            IoUtils.closeQuietly(out);
+        }
+    }
+
+    private void serializeLockedApps(XmlSerializer serializer) throws IOException {
+        serializer.startTag(null, TAG_LISTED_DOMAINS);
+        for (String domain : mDomainsList) {
+            serializer.startTag(null, TAG_DOMAIN);
+            serializer.attribute(null, ATTRIBUTE_NAME, domain);
+            serializer.endTag(null, TAG_DOMAIN);
+        }
+        serializer.endTag(null, TAG_LISTED_DOMAINS);
+    }
+
+    private void resetDnsConf() {
+        ArrayList<String> confLines = new ArrayList<String>();
+        boolean blacklist = isBlacklistMode();
+        File dnsmasqDir = new File(Environment.getDataSystemCeDirectory(mUserId), "dnsmasq");
+        if (!dnsmasqDir.exists() && !dnsmasqDir.mkdirs())
+            Slog.e(TAG, "Error while creating dnsmasq directory: " + dnsmasqDir);
+        if (mDomainsList.size() > 0) {
+            for (String domain : mDomainsList) {
+                if (blacklist)
+                    confLines.add("address=/" + domain + "/127.0.0.1");
+                else
+                    confLines.add("server=/" + domain + "/" + COMMON_DNS);
+            }
+            if (!blacklist)
+                confLines.add("address=/#/127.0.0.1");
+            try {
+                Files.write(Paths.get(dnsmasqDir.getAbsolutePath() + "/dns.conf"),
+                  confLines, StandardCharsets.UTF_8);
+            } catch (IOException e) {
+                Slog.wtf(TAG, "Failed to write dnsmasq config", e);
+            }
+        }
+        if (isActivate())
+            SystemProperties.set("ctl.restart", "volla.dnsmasq");
+    }
+
+    public void activate(boolean enable) {
+        SystemProperties.set("persist.volla.firewall.enable", enable ? "true" : "false");
+        if (enable) {
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+            SystemProperties.set("ctl.start", "volla.dnsmasq");
+        } else {
+            SystemProperties.set("ctl.stop", "volla.dnsmasq");
+        }
+        ConnectivityManager connectivityManager = (ConnectivityManager)mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
+        IDnsResolver resolver = IDnsResolver.Stub
+                .asInterface(ServiceManager.getService("dnsresolver"));
+        MockableSystemProperties systemProperties = new MockableSystemProperties();
+        DnsManager dnsManager = new DnsManager(mContext, resolver, systemProperties);
+        Network network = connectivityManager.getActiveNetwork();
+        LinkProperties linkProperties = connectivityManager.getActiveLinkProperties();
+        PrivateDnsConfig cfg = dnsManager.getPrivateDnsConfig();
+        if (network != null) {
+            dnsManager.updatePrivateDns(network, cfg);
+            dnsManager.updateTransportsForNetwork(network.netId, IntStream.range(MIN_TRANSPORT, MAX_TRANSPORT).toArray());
+            dnsManager.noteDnsServersForNetwork(network.netId, linkProperties);
+            dnsManager.sendDnsConfigurationForNetwork(network.netId);
+            dnsManager.setDefaultDnsSystemProperties(linkProperties.getDnsServers());
+            dnsManager.flushVmDnsCache();
+            dnsManager.updatePrivateDnsStatus(network.netId, linkProperties);
+        }
+    }
+
+    public boolean isActivate() {
+        return SystemProperties.getBoolean("persist.volla.firewall.enable", false);
+    }
+
+    public void blacklistMode(boolean enable) {
+        SystemProperties.set("persist.volla.blacklist.enable", enable ? "true" : "false");
+        if (isActivate())
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+    }
+
+    public boolean isBlacklistMode() {
+        return SystemProperties.getBoolean("persist.volla.blacklist.enable", false);
+    }
+
+    private void addDomainToList(String domain) {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "addDomainToList domain:" + domain);
+        if (!mDomainsList.contains(domain)) {
+            mDomainsList.add(domain);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_STATE);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+        }
+    }
+
+    private void removeDomainFromList(String domain) {
+        if (mDomainsList.contains(domain)) {
+            mDomainsList.remove(domain);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_STATE);
+            mHandler.sendEmptyMessage(FirewallHandler.MSG_WRITE_CONF);
+        }
+    }
+
+    public boolean isDomainOnList(String domain) {
+        return mDomainsList.contains(domain);
+    }
+
+    private List<String> getDomainsList() {
+        return mDomainsList;
+    }
+
+    private int getDomainsListCount() {
+        if (DEBUG_FIREWALL) Slog.v(TAG, "Number of domains on list: " + mDomainsList.size());
+        return mDomainsList.size();
+    }
+
+    private final IBinder mService = new IFirewallService.Stub() {
+        @Override
+        public void activate(boolean enable) {
+            FirewallService.this.activate(enable);
+        }
+
+        @Override
+        public boolean isActivate() {
+            return FirewallService.this.isActivate();
+        }
+
+        @Override
+        public void blacklistMode(boolean enable) {
+            FirewallService.this.blacklistMode(enable);
+        }
+
+        @Override
+        public boolean isBlacklistMode() {
+            return FirewallService.this.isBlacklistMode();
+        }
+
+        @Override
+        public void addDomainToList(String domain) {
+            FirewallService.this.addDomainToList(domain);
+        }
+
+        @Override
+        public void removeDomainFromList(String domain) {
+            FirewallService.this.removeDomainFromList(domain);
+        }
+
+        @Override
+        public boolean isDomainOnList(String domain) {
+            return FirewallService.this.isDomainOnList(domain);
+        }
+
+        @Override
+        public int getDomainsListCount() {
+            return FirewallService.this.getDomainsListCount();
+        }
+
+        @Override
+        public List<String> getDomainsList() {
+            return FirewallService.this.getDomainsList();
+        }
+    };
+
+    private class FirewallHandler extends Handler {
+
+        public static final int MSG_INIT_APPS = 0;
+        public static final int MSG_WRITE_STATE = 1;
+        public static final int MSG_WRITE_CONF = 2;
+
+        public FirewallHandler(Looper looper) {
+            super(looper);
+        }
+
+        @Override
+        public void handleMessage(android.os.Message msg) {
+            switch (msg.what) {
+                case MSG_INIT_APPS:
+                    initLockedApps();
+                    break;
+                case MSG_WRITE_STATE:
+                    writeState();
+                    break;
+                case MSG_WRITE_CONF:
+                    resetDnsConf();
+                    break;
+                default:
+                    Slog.w(TAG, "Unknown message:" + msg.what);
+            }
+        }
+    }
+}
diff --git a/lineage/res/res/values/config.xml b/lineage/res/res/values/config.xml
index 62ea4c11..cdb4b6ee 100644
--- a/lineage/res/res/values/config.xml
+++ b/lineage/res/res/values/config.xml
@@ -108,6 +108,7 @@
         <item>org.lineageos.platform.internal.LineageSettingsService</item>
         <item>org.lineageos.platform.internal.LineageGlobalActionsService</item>
         <item>org.lineageos.platform.internal.AppLockService</item>
+        <item>org.lineageos.platform.internal.FirewallService</item>
     </string-array>
 
     <!-- The LineageSystemServer class that is invoked from Android's SystemServer -->
diff --git a/sdk/src/java/lineageos/app/LineageContextConstants.java b/sdk/src/java/lineageos/app/LineageContextConstants.java
index eb956fa5..20f99fbe 100644
--- a/sdk/src/java/lineageos/app/LineageContextConstants.java
+++ b/sdk/src/java/lineageos/app/LineageContextConstants.java
@@ -95,6 +95,13 @@ public final class LineageContextConstants {
      */
     public static final String VOLLA_APPLOCK_SERVICE = "vollaapplock";
 
+    /**
+     * Volla Firewall
+     *
+     * @hide
+     */
+    public static final String VOLLA_FIREWALL_SERVICE = "vollafirewall";
+
     /**
      * Features supported by the Lineage SDK.
      */
diff --git a/sdk/src/java/lineageos/firewall/FirewallManager.java b/sdk/src/java/lineageos/firewall/FirewallManager.java
new file mode 100644
index 00000000..10a2c649
--- /dev/null
+++ b/sdk/src/java/lineageos/firewall/FirewallManager.java
@@ -0,0 +1,147 @@
+/**
+ * Copyright (C) 2022 Hallo Welt Systeme UG
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lineageos.firewall;
+
+import android.content.Context;
+import android.os.IBinder;
+import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.os.ServiceManager.ServiceNotFoundException;
+import android.util.Log;
+
+import lineageos.app.LineageContextConstants;
+
+import java.util.List;
+
+public class FirewallManager {
+    private static final String TAG = "FirewallManager";
+
+    private static IFirewallService sService;
+    private static FirewallManager sInstance;
+
+    private Context mContext;
+
+    private FirewallManager(Context context) {
+        Context appContext = context.getApplicationContext();
+        mContext = appContext == null ? context : appContext;
+        sService = getService();
+        if (sService == null) {
+            throw new RuntimeException("Unable to get FirewallService. The service" +
+                    " either crashed, was not started, or the interface has been called to early" +
+                    " in SystemServer init");
+        }
+    }
+
+    public static FirewallManager getInstance(Context context) {
+        if (sInstance == null) {
+            sInstance = new FirewallManager(context);
+        }
+        return sInstance;
+    }
+
+    /** @hide **/
+    public static IFirewallService getService() {
+        if (sService != null) {
+            return sService;
+        }
+        IBinder b = ServiceManager.getService(LineageContextConstants.VOLLA_FIREWALL_SERVICE);
+
+        if (b == null) {
+            Log.e(TAG, "null service. SAD!");
+            return null;
+        }
+
+        sService = IFirewallService.Stub.asInterface(b);
+        return sService;
+    }
+
+    public FirewallManager(IFirewallService service) {
+        sService = service;
+    }
+
+    public void activate(boolean enable) {
+        try {
+            sService.activate(enable);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public boolean isActivate() {
+        try {
+            return sService.isActivate();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public void blacklistMode(boolean enable) {
+        try {
+            sService.blacklistMode(enable);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public boolean isBlacklistMode() {
+        try {
+            return sService.isBlacklistMode();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public void addDomainToList(String domain) {
+        try {
+            sService.addDomainToList(domain);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public void removeDomainFromList(String domain) {
+        try {
+            sService.removeDomainFromList(domain);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public boolean isDomainOnList(String domain) {
+        try {
+            return sService.isDomainOnList(domain);
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public int getDomainsListCount() {
+        try {
+            return sService.getDomainsListCount();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+
+    public List<String> getDomainsList() {
+        try {
+            return sService.getDomainsList();
+        } catch (RemoteException e) {
+            throw e.rethrowFromSystemServer();
+        }
+    }
+}
diff --git a/sdk/src/java/lineageos/firewall/IFirewallService.aidl b/sdk/src/java/lineageos/firewall/IFirewallService.aidl
new file mode 100644
index 00000000..d9d9d67b
--- /dev/null
+++ b/sdk/src/java/lineageos/firewall/IFirewallService.aidl
@@ -0,0 +1,39 @@
+/**
+ * Copyright (C) 2022 Hallo Welt Systeme UG
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lineageos.firewall;
+
+/** @hide */
+interface IFirewallService {
+
+    void activate(boolean enable);
+
+    boolean isActivate();
+
+    void blacklistMode(boolean enable);
+
+    boolean isBlacklistMode();
+
+    void addDomainToList(String domain);
+
+    void removeDomainFromList(String domain);
+
+    boolean isDomainOnList(String domain);
+
+    int getDomainsListCount();
+
+    List<String> getDomainsList();
+}
-- 
2.29.2

